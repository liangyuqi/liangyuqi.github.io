---
layout:     post
title:      js运行机制以及定时器原理详解
subtitle:   
date:       2017-11-01
author:     Liangyuqi
header-img: img/post-bg-18.jpg
catalog: true
tags:
    - javascript
---

### js的单线程
JavaScript作为浏览器脚本语言，主要用途是与用户互动，以及**操作DOM**。这决定了它只能是单线程，否则会带来很复杂的同步问题。

比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

为了利用多核CPU的计算能力，HTML5提出**Web Worker**标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

> var worker = new Worker('js/test.js');
> 
> 构造函数的参数填上你的js文件的路径，这个js文件将会在浏览器新开的线程里运行，而与原先的js引擎的线程并不影响。
> 
> 主线程首先创建Worker，通过Worker对象的postMessage方法，将数据传递给后台线程，而主程序通过onmessage 事件，或者自定义addEventListener 事件来监听后台返回后台线程处理的结果。
> 
> 同样，后台线程通过onmessage事件来接收主页面传递的数据，通过postMessage将处理结果返回给主页面。

> 我们可以做什么：
> 
> 1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信
> 
> 2.可以在worker中通过importScripts(url)加载另外的脚本文件
> 
> 3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval()
> 
> 4.可以使用XMLHttpRequest来发送请求
> 
> 5.可以访问navigator的部分属性
> 
> 有那些局限性：
> 
> 1.不能跨域加载JS
> 
> 2.worker内代码不能访问DOM
> 
> 3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行
> 
> 4.不是每个浏览器都支持这个新特性

### 浏览器的多线程

JS是单线程的，但是对于浏览器来说JS的执行只不过是在浏览器众多线程中的一条，我们称之为JS引擎线程。

而浏览器的其他线程则是通过JS引擎线程在执行到某个特定的功能之后指定给浏览器的对应线程。

> 1.js引擎线程(js引擎有多个线程，一个主线程，其它的后台配合主线程) 
> 
> 作用：执行js任务(执行js代码，用户输入，网络请求)
> 
> 2.ui渲染线程 
> 
> 作用：渲染页面(js可以操作dom，影响渲染，所以js引擎线程和UI线程是互斥的。js执行时会阻塞页面的渲染。)
> 
> 3.浏览器事件触发线程 
> 
> 作用：控制交互，响应用户
> 
> 4.http请求线程 
> 
> 作用：ajax请求等
> 
> 5.定时触发器线程 
> 
> 作用：setTimeout和setInteval
> 
> 6.事件轮询处理线程 
> 
> 作用：轮询消息队列，event loop

### 同步任务和异步任务

同步任务：在主线程排队支持的任务，前一个任务执行完毕后，执行后一个任务,形成一个执行栈，线程执行时在内存形成的空间为栈，进程形成堆结构，这是内存的结构。执行栈可以实现函数的层层调用。（`注意不要理解成同步代码进入栈中，按栈的出栈顺序来执行`）
 
异步任务：会被主线程挂起，不会进入主线程，而是进入消息队列，而且必须指定回调函数，只有消息队列通知主线程，并且执行栈为空时，该消息对应的任务才会进入执行栈获得执行的机会。

### 主线程执行的说明:

![](http://image.beekka.com/blog/2014/bg2014100802.png)

上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。

1. 所有同步任务都在主线程上执行，形成一个**执行栈（execution context stack）**。 
1. 主线程之外，还存在一个**”任务队列”（task queue）**。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 
1. 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 
1. 主线程不断重复上面的第三步。

### 事件循环 
主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为**Event Loop（事件循环）**。 

### 定时器

定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。

setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。
	 setTimeout("alert('定时器!')",0);
	 alert("测试")

如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。

上面代码的执行结果总是“测试”，“定时器”，因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数。

**定时器是会在进入消息队列，这也就和异步代码的执行逻辑一样了。它在”消息队列”的尾部添加一个消息，因此要等到同步任务和”消息队列”现有的任务都处理完，才会得到执行的机会，还要看定时器设置的时间是否到了才会执行。**

> HTML5规范中规定定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。
> 
> 定时器不是完全的可靠的，存在极小的误差

**setTimeout：在指定时间内, 将任务放入事件队列,等待js引擎空闲后被执行.**

**setInterval(fn, 100)：setInterval并不管上一次fn的执行结果，而是每隔100ms就将fn放入主线程队列，而两次fn之间具体间隔多久就不一定了，跟setTimeout实际延迟时间类似，和JS执行情况有关。具体的延迟效果与内存等因素有关。**

> 定时器的妙用:耗时代码的优化
> 50万个节点分成多组，每组渲染  的节点数不要过多，然后通过setInterval来进行循环这个既不阻塞JS引擎线程的运行，又不可以提高渲染的消>耗时间。从而达到最终的优化渲染。

